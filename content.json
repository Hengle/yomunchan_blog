{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"friends","text":"","link":"/friends/index.html"}],"posts":[{"title":"【科普向】如何在“996ICU”项目上点一个小星星","text":"“996ICU”是近期Github上由中国程序员发起的一个很火热的项目，发布不到半个月，便已经有了十几万的小星星。这种有话题性的项目，自然也引来了很多非程序行业的小伙伴的围观和参与。本文就是为非程序行业的小伙伴介绍一下，如何在Github中给这个项目点一个小星星。 科普1：Github Github是全世界程序员之间以共享代码为主的网站，几乎是全世界计算机行业发展必不可少的一部分。被誉为“互联网上可能最早实现共产主义的地方”、“全球同性社交网站” 首先， 目前为止，很多国内资本的浏览器开始有意无意的屏蔽这个项目了。 所以我们得有一个非国产的浏览器。比如大家电脑上自带的“Microsoft Edge”，或是下载Firefox浏览器（点击前往）. 然后，通过浏览器，打开996icu项目的地址：https://github.com/996icu/996.icu 然后，我们只需要做两件事：1. 注册一个Github账号 2.点一下项目右上角的小星星。 然后就完成啦。 注册：点击页面右上角的“Sign up”开始注册 然后，它会让我们选择一个账户付费方案，默认是免费的，我们不用管 好了，现在Github会给我们发送一封邮件以确认注册，我们打开我们的邮箱 好了，到这一步为止，我们已经完成了账户注册的全部工作 现在，我们重新打开996icu的页面： https://github.com/996icu/996.icu 点一下右上角的“Star”按钮，就完成了！","link":"/2019/04/02/e3-80-90-e7-a7-91-e6-99-ae-e5-90-91-e3-80-91-e5-a6-82-e4-bd-95-e5-9c-a8996icu-e9-a1-b9-e7-9b-ae-e4-b8-8a-e7-82-b9-e4-b8-80-e4-b8-aa-e5-b0-8f-e6-98-9f-e6-98-9f/"},{"title":"【Unity 2019】在编辑器的Project Settings窗口中添加自定义设置项","text":"在Unity的新版本中，有个挺大的变化就是：Project Setting的一堆配置项从Inspector中独立出来，单独弄了一个窗口。 实际上，我们也可以把自己游戏里的一些配置工具，也给整到这个窗口里面去。 需求在我写的一个Unity开发框架中， 有很多配置文件(继承自ScriptableObject类的.asset文件)。众所周知，Unity上编辑.asset配置文件的方法特别诡异：你得在Project窗口里选中这个文件，然后它的配置内容就会出现在Inspector窗口上。 这样的问题是，比如说你需要往配置文件里填一个文件名，然后你去找这个文件在哪，然后右键这个文件复制它的路径…… 好了现在问题来了，你在去找文件的操作中，你刚刚选择的那个配置文件就失焦了（不再是activeObject了），于是Inspector上也就没有配置选项了。 “诶我刚刚配置一半的东西哪去了”，然后你还得再回来在一堆文件夹中找到刚刚的配置文件，选中它。 一次两次还能忍，如果要配置很多东西进去，是不是就得骂人了。 于是，在一开始，我们的解决方法是，用Odin插件写一个窗口，把开发框架里的一堆配置文件归整到一起来。 就像这样，其实和Unity新出的Project Settings窗口功能和结构都差不多。（那么我为什么要自己搞一个呢，因为我做这个窗口的时候，Unity还没新出这个功能。 这个窗口其实本质上也还是在操作那一堆.asset配置文件。 然而Odin是个付费插件，如果我们想把我们的开发框架分享给团队之外的人使用的话，就出现问题了。所以渐渐的，就有了一个诉求：让我们的开发框架脱离Odin之后也能使用。 正好最近Unity2019发布了，灵机一动：诶，要不我们让开发框架在监测到工程里没有Odin插件的时候，把配置文件都整合到这个新出的Project Settings窗口里试试呗。于是，随着一通折腾，就有了这么个文章。 其实Project Settings独立窗口是2018.3就开始有的功能，不是2019的新功能。但是被Unity搞怕了，新功能默认推迟一个版本再去用。 我们来看看最终效果（我就先实现了一个）： 开始实现 首先，得定义一个配置文件的类（其实就是普通的ScriptableObject类，里面搞了一堆#if 的判断是为了让它在没有Odin插件的时候也能工作，无视即可。 然后，我们需要在编辑器下（Editor目录）重新定义一个类，用来告诉Unity的编辑器：“我要在你的设置窗口里显示东西！” 一个简单的结构如下： 其实乍一看，原理很像“[MenuItem(xxxxx)]”那种定义方法，倒确实是Unity的一贯风格。 在一个静态类下，使用“SettingProviderAttribute”这个attribute来标记一个静态方法（强调：静态方法，和定义menu一样），这个方法要返回一个“SettingProvider”的对象。 然后我们看看效果： 可以看到，我们定义的设置项已经起作用了，但是里面什么都没有。有一个叫“喵”的配置项在Project Settings窗口的Project目录下，这个地方是因为我们定义的路径是“Project/喵”，和菜单的玩法一样，如果我们不以“Project/”开头的话，它就会成为一个顶级目录。 接下来，我们来往里面填内容。在官方文档里，有三种方法： IMGUI方式 UIElement方式 用一个子类继承SettingsProvider类 这里我们使用IMGUI方式，（因为暂时不想写css，小布局没必要搞那么复杂。 代码写好后如下： 嗯，所以看起来，其实挺好理解的，就是一个经典的编辑器UI写法的魔改版。就和平时写编辑器UI时候一样，在OnGUI方法里用“GUILayout/EditorGUIlayout”类绘制UI一样。 那么到此为止，一个自定义的设置项就做好了。 (其实在Preferences窗口里自定义内容，也是同样的原理 。 当然，举一反三：UIElement的写法就是在”activateHandler”这个回调里面初始化 UIElement的代码咯。 顺便一说，activateHandler 的参数 “rootElement”，如果它里面有了子元素的话，Unity就认为这是采用UIElement方式绘制UI，那么guiHandler这个回调就会被无视，不会触发了。 (由于UIElement也是新功能，很多人可能还没开始接触。如果你不知道这里说的是啥的话，直接无视就好了。 说句题外话，自定义设置项的方法挺好理解的，就和做编辑器UI一样，但是闹心的地方也在这儿了。相当于你得自己写GUI再把.asset配置文件里的配置项再挨个实现一遍。太繁琐了。 相比之下，Odin插件实现的窗口就比较省事了，拿到.asset文件的对象之后，它可以自己去反射里面的配置项和调整布局。开头截图的那个窗口，核心代码就是下面几句话。 我总觉得Unity应该把Odin买下来内置进编辑器，Unity编辑器自带的各种东西太蠢了。","link":"/2019/05/02/e3-80-90unity-2019-e3-80-91-e5-9c-a8-e7-bc-96-e8-be-91-e5-99-a8-e7-9a-84project-settings-e7-aa-97-e5-8f-a3-e4-b8-ad-e6-b7-bb-e5-8a-a0-e8-87-aa-e5-ae-9a-e4-b9-89-e8-ae-be-e7-bd-ae-e9-a1-b9/"},{"title":"【C++小日常】他说，读过书，我便考你一考。C++的include，怎样写的？","text":"有一回对我说道，“你读过书么？”我略略点一点头。他说，“读过书，……我便考你一考。C++的include，怎样写的？” 在我们一开始接触标准C++的时候，一定都写过这么一段话： #include using namespace std; 但是有时候啊，我们又看到 #include &lt;iostream.h&gt; //这里是VC++ 6.0方言版本写法 那么问题来了，它们为什么是不一样的呢，我以前的解释是：“VC++ 6.0是现代C++标准推出之前的产物，属于方言”， 那么为什么会有这样的方言呢，include到底是怎么写呢，此文就来大概说道说道。为了探寻上古VC++6.0的方言是这么造成的，我们探访到了MSDN上古时期的页面，https://msdn.microsoft.com/en-us/library/aa229433(v=VS.60).aspx 这里的解释以此为参考。首先，现代标准的两句话，到底说了什么呢。 #include 引入了一个叫输入输出流的东西，而在C++标准程序库中，所有的标识符都被定义于一个叫std的namespace中，所以，我们才会写出第二行： using namespace std; 以此引用标准库std， 而翻阅了大量上古资料之后，我们发现了VC++ 6.0的一些奇特之处。简单的说，在VC++ 6.0中，iostream这样的东西有两套。 首先#include&lt;iostream.h&gt;是方言写法没错，此外另一点就是，#include+using和#include&lt;iostram.h&gt;并不是同一种功能的两种表达方式，而是两种不同的东西。方言写法中，并非引入整个命名空间，而是引入一个具体的、6.0特有的库文件。 现代标准的#include到底应该怎么写呢？ 我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。孔乙己等了许久，很恳切的说道，“不能写罢？……我教给你，记着！这些写法应该记着。将来做程序的时候，写C++要用。”我暗想我和程序员的等级还很远呢，而且程序员也从亲自写Include,只是从Github上抄抄罢；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是井号include加头文件么？”孔乙己显出极高兴的样子，将两个指头的长指甲敲着键盘，点头说，“对呀对呀！……include有两样写法，你知道么？”我愈不耐烦了，努着嘴走远。 那么说了这么多之后，问题来了，现代标准的#include到底应该怎么写呢？ 它有两种写法： #include &lt;&gt; #include “” 其中，#include &lt;&gt;的写法，它会指示预处理程序到预定义的缺省路径下寻找文件。而预定义的缺省路径通常是在INCLUDE环境变量中指定的。 如果使用这种写法，编译程序会首先到环境变量的路径下寻找文件，如果没有找到，会到当前目录下继续寻找。 而使用双引号#include “file” 的写法，这种方法会指示预处理其先到当前目录下寻找文件，再到预定义的缺省路径下寻找文件。 好了，这个简答的问题理解了之后，下面我扩展一下，这部分用红色写的部分，算作是一些知识扩展，不一定非要掌握了。 比如说，当前目录下有个文件叫“hello.h”，当前目录下有个子目录叫“dir1”,,在dir1中有也有一个hello.h，还有一个main.c 如果说在main.c文件中，#include “hdr.h”,那么在当前目录下编译”dir1/main.c”，它包含的应该是哪个hello.h呢。 正确答案是“dir1/hello.h”，在gcc和msvc中，include””的写法说代表的“在当前目录寻找”，其实是指在使用了include的源文件的所在目录寻找，而不是编译器的当前工作目录。 实际上这种逻辑，并不在C99的规范之中，而是一种约定俗成的行业规范， 想明白这个问题之后，我们来看看下一个问题，有时候我们会看到#include &lt;string.h&gt; 而有时候我们会看到#include ，它们之间又是什么区别呢？ include后面什么时候加.h？加不加.h有什么区别？ 以string.h为例，简单的一句话解释是： string.h是C语言的头文件，包含C语言字符串处理函数， string 是C++头文件，包含C++字符串class。 .h是C语言的习惯，标准C++库中所有头文件都是不加.h的 这里我们引用一段《effective C++》的话， 条款49: 熟悉标准库 C++标准库很大。非常大。难以置信的大。怎么个大法？这么说吧：在C++标准中，关于标准库的规格说明占了密密麻麻300多页，这还不包括标准C库，后者只是 “作为参考”（老实说，原文就是用的这个词）包含在C++库中。 当然，并非总是越大越好，但在现在的情况下，确实越大越好，因为大的库会包含大量的功能。标准库中的功能越多，开发自己的应用程序时能借助的功能就越多。C++库并非提供了一切（很明显的是，没有提供并发和图形用户接口的支持），但确实提供了很多。几乎任何事你都可以求助于它。 在归纳标准库中有些什么之前，需要介绍一下它是如何组织的。因为标准库中东西如此之多，你（或象你一样的其他什么人）所选择的类名或函数名就很有可能和标准库中的某个名字相同。为了避免这种情况所造成的名字冲突，实际上标准库中的一切都被放在名字空间std中（参见条款28）。但这带来了一个新问题。无数现有的C++代码都依赖于使用了多年的伪标准库中的功能，例如，声明在&lt;iostream.h&gt;，&lt;complex.h&gt;，&lt;limits.h&gt;等头文件中的功能。现有软件没有针对使用名字空间（这里可能想说的是namespace）而进行设计，如果用std来包装标准库导致现有代码不能用，将是一种可耻行为。（这种釜底抽薪的做法会让现有代码的程序员说出比 “可耻” 更难听的话） 慑于被激怒的程序员会产生的破坏力，标准委员会决定为包装了std的那部分标准库构件创建新的头文件名。生成新头文件的方法仅仅是将现有C++头文件名中的 .h 去掉，方法本身不重要，正如最后产生的结果不一致也并不重要一样。所以&lt;iostream.h&gt;变成了，&lt;complex.h&gt;变成了，等等。对于C头文件，采用同样的方法，但在每个名字前还要添加一个c。所以C的&lt;string.h&gt;变成了，&lt;stdio.h&gt;变成了，等等。最后一点是，旧的C++头文件是官方所反对使用的（即，明确列出不再支持），但旧的C头文件则没有（以保持对C的兼容性）。实际上，编译器制造商不会停止对客户现有软件提供支持，所以可以预计，旧的C++头文件在未来几年内还是会被支持。 所以，实际来说，下面是C++头文件的现状： · 旧的C++头文件名如&lt;iostream.h&gt;将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在名字空间std中。 · 新的C++头文件如包含的基本功能和对应的旧头文件相同，但头文件的内容在名字空间std中。（在标准化的过程中，库中有些部分的细节被修改了，所以旧头文件和新头文件中的实体不一定完全对应。） · 标准C头文件如&lt;stdio.h&gt;继续被支持。头文件的内容不在std中。 · 具有C库功能的新C++头文件具有如这样的名字。它们提供的内容和相应的旧C头文件相同，只是内容在std中。 所有这些初看有点怪，但不难习惯它。最大的挑战是把字符串头文件理清楚：&lt;string.h&gt;是旧的C头文件，对应的是基于char*的字符串处理函数；是包装了std的C++头文件，对应的是新的string类（看下文）；是对应于旧C头文件的std版本。如果能掌握这些（我相信你能），其余的也就容易了。","link":"/2018/09/19/e3-80-90c-e5-b0-8f-e6-97-a5-e5-b8-b8-e3-80-91-e4-bb-96-e8-af-b4-ef-bc-8c-e8-af-bb-e8-bf-87-e4-b9-a6-ef-bc-8c-e6-88-91-e4-be-bf-e8-80-83-e4-bd-a0-e4-b8-80-e8-80-83-e3-80-82c-e7-9a-84include/"},{"title":"【Unity】自己动手做一个剧情对话系统吧","text":"Nekopara 在游戏中，我们总是会见到上图这种剧情对话功能，它在很多尤其中，尤其是galgame中，起着重要的作用。 那么，这样的系统，要怎么做呢， 我们可以大致分为两部分： 对话剧情的编写 运行编写好的剧情内容 其实在我看来，做这么一套系统，最大的难点，其实是在第一条：怎么设计一套编写剧情对话的东西。 在我这种典型的程序员的视角来看，直接拿Lua脚本写剧情就非常棒，比如这样 local dialogue = {} local Mgr = XCore.Drama.DialogueManager; dialogue[1] = Mgr.Say(&quot;史莱姆&quot;,&quot;我也是个广东人，所以我们是老乡&quot;); dialogue[2] = Mgr.Say(&quot;哥布林&quot;,&quot;花~Q&quot;); dialogue[3] = Mgr.Say(&quot;史莱姆&quot;,&quot;oh, 花可U,Leather Man~&quot;); return dialogue;这样对于程序员来说，显然是最爽的，你甚至不用刻意去解析它，拿到数据之后直接就可以运行了。但是问题是，一般在做游戏的时候，都不是程序员去编写剧情脚本的，而是文案啊、策划啊之类的。你让非程序工作者去直接写Lua，先不说会不会出错，他们肯定会先想着怎么把程序员打一顿的。 所以，这样是行不通的，那有没有其他方案呢。 诶，好像我工作的公司的项目中就有对话系统，我去看看他们是怎么弄的。然后，我们看到他们把所有对话文本，都配在了Excel中。 emmm，乍一看好像没问题，但是遇到选择项的时候，这么操作就非常繁琐了。 比如： 史莱姆：“我也是个广东人，所以我们是老乡”。 请选择操作： “ 花~Q! ” “雷猴啊” 不理她 那么，在这样一个选项中，每个选项之后，会有不同的对话内容，甚至还有不同的选项对角色的某些属性的影响。（比如选择“ 花~Q! ”会让史莱姆对自己的好感度+10 这类的功能） 这样的话，Excel配表格这种操作，就显得有很大局限性了。（那为什么我司的项目用Excel呢，我问了下，他们说游戏里不可能有太过复杂的剧情对话，但是对于做Galgame之类的情况，就完全不够用了）。 于是，接下来，我们来看看网络上有什么不错的解决方案，然后，我找到了这个：Ink语言。 ink是由inkle公司推出的一种脚本式的文字预处理语言用来编写一些对话类游戏的对话内容及流程图。 写起来大概是这样： 史莱姆：我也是个广东人，所以我们是老乡。 请选择操作： * “花~Q!” [] oh, 花可U,Leather Man~ * “两开花！两开花！”这套语言设计的就很棒了，功能强大，写起来也还不错，甚至，它有专门的Unity插件来解析ink语言：https://assetstore.unity.com/packages/tools/integration/ink-unity-integration-60055 于是呢，我就把这玩意给拿给我们文案看了，文案表示，这个好像还是有挺高的学习成本诶，而且看着也不是很直观。有点乱乱的。 然后，我就自己撸了一套，长这样 嗯，利用图表节点来描述对话流程。 在节点图表中，你可以直接通过连线的方向，复用之前的节点 运行如下： 分支选项 两开花选项 再次回到分支选项时，设定为“只能选择一次”的两开花选项消失 此外，配合一些参数绑定的功能，和事件广播的功能，一个简单的对话系统就做好了。 开源引用CatLib: CatLib - 文档 xNode : xNode - Asset Store","link":"/2019/02/02/e3-80-90unity-e3-80-91-e8-87-aa-e5-b7-b1-e5-8a-a8-e6-89-8b-e5-81-9a-e4-b8-80-e4-b8-aa-e5-89-a7-e6-83-85-e5-af-b9-e8-af-9d-e7-b3-bb-e7-bb-9f-e5-90-a7/"},{"title":"在Unity Editor中调试TinaX的AssetBundle","text":"在TinaX Framework中，我们使用VFS（虚拟文件系统）来进行资源的管理与加载。但实际上，VFS在编辑器下并不会实际打包和加载AssetBundle，而是直接使用UnityEditor.AssetDatabase进行加载。但是这样一来，有些在真正使用AssetBundle时候才会遇到的坑就没法在开发的时候测试和排查了。 那怎么办呢，我们得在编辑器上真实的去打包并加载AssetBundle进行测试。 打包第一步，当然先把Assetbundle包打出来。在菜单中打开资源打包面板。 然后，选择当前编辑器所在的平台对工程进行全部打包， 疯狂读条 打包完成后，我们把资源移动到Unity的工程下，首先点击面板下方的“管理VFS资源”。 点击选择刚刚打包的资源。 点击“移动到StreamingAssets” 等Unity一通读条后，打包工作完成。 在编辑器下使用AssetBundle加载资源勾选下图所示的菜单中的“从资源包加载”选项后，运行游戏时，TinaX会直接加载Assetbundle资源 这里要注意的时，如果你使用lua语言开发游戏的话，lua语言文件也会被打成assetbundle包，这就意味着，修改完lua代码后要重新打包后运行才会生效。 查看已加载资源此时，运行游戏时，我们可以通过菜单“TinaX-&gt;编辑器-&gt;资源系统-&gt;AB资源加载检测”来查看当前的assetbundle包的使用情况 在列出的内容中，“[1]assets/xxx/xxx”, 其中中括号中的数字是当前该资源包被引用的次数。数字为0时，代表当前资源包目前仍然在内存中，但是并没有被任何功能使用，这类资源将在下次调用GC方法时被释放。","link":"/2019/07/29/e5-9c-a8unity-editor-e4-b8-ad-e8-b0-83-e8-af-95tinax-e7-9a-84assetbundle/"},{"title":"寻找Adobe全家桶的替代品【长期更新】","text":"Adobe系列大多经历了十几二十多年的发展，基本上已经是行业事实标准的地位了。Adobe系列的软件都挺好的，可就是有一个问题：贵 贵，令人无法忍受的贵。于是，就有了这篇文字，让我们来看看，Adobe系的东西，都分别有哪些替代品。 目录 Adobe PhotoShop Adobe Permiere Pro Adobe illustrator Adobe Flash Adobe PhotoShop售价20.99美元/月。 平面设计用途：Affinity Photo Affinity Photo (Microsoft Store 版本) Affinity Photo是一个一开始就奔着PS去的软件,甚至在部分功能上对PS弯道超车，在使用上，有PS使用经验的艺术家可以在快速上手AP。Affinity Photo可以直接在官网购买 ，也可以在Microsoft Store和 Mac App Store上购买（应用商店的下载速度对国内友好）。 AP兼容PS格式(psd)，支持Windows / Mac双平台，兼容PS的插件，可在团队内部平滑过渡。 而且AP的价格也算美丽： Windows / Mac ：328元 永久 iOS：128 元 永久 推荐分数：5 Pixelmator Pro 图片来自官网（懒得从柜子里找mac出来充电然后截图了 Pixelmator Pro 也是一个功能上和PS差不多的平面设计软件，操作逻辑自成一体，从PS转移过来会有一定不适感。但熟悉之后，感觉还行。 Pixelmator Pro仅支持Mac平台，如果团队内有依赖PS的自动化工具、或者团队内有Windows的话，可能没法很愉快的换工具。 售价： 39.99 美元 （仅限Mac平台 推荐分数：4 Gimp GIMP Windows 说实话，我觉得Gimp有点别扭，但它值得拥有姓名。GIMP是一个由开源社区维护的开源软件。以前的GIMP其实很别扭，但是最近GIMP也明显做的越来越好了。 GIMP兼容PS格式，但对于非栅格化的图层的兼容有一定问题，不建议团队内同时使用GIMP和PS。插件方面GIMP自成一体，而且挺丰富的。（但是依托于开源社区的生态可能对设计师不太友好 售价： 免费 （Windows / GNU Linux / OS X 推荐分数：3.5 绘画用途Clip Studio Paint（CSP） CSP 国内代理版（优动漫 PAINT） 其实倒是不存在CSP是PS在绘画领域的替代品这种说法，因为在不少画家眼中，CSP本来就是“吊打”PS的存在。实际体验上，CSP该有的都有了。 CSP支持Windows / Mac平台，国内代理软件名为“优动漫 PAINT”，听起来有点蠢 售价：（国内代理版本） 个人版：258元 EX版：1158元 推荐分数：5 PaintTool SAI （SAI） 第三方汉化版 说到绘画，应该没人不知道SAI了，经典的老牌绘画软件，在绘画领域有着举足轻重的地位和“坚信可以吊打PS”的大量忠实用户。个人体验上感觉没啥问题，之前问一个画师朋友说有的功能上比PS有所欠缺。 不过，个人体验来看，SAI目前对触屏设备支持较差：它好像不能很好的分辨哪个是笔，哪个是放在屏幕上的手。推荐使用数位板配合绘画。 顺带一说，SAI官网好像并没有发现mac平台支持的信息，但是搜索引擎中好像有关于mac版的内容，不知道怎么回事，这里以官网为准，认为它不支持mac平台吧。 售价： Windows ：5400 円（日元） 推荐分数：4.8 Affinity Photo好了又见面了，AP。正如之前所说，Affinity Photo一开始就是奔着PS去的，这其中也包括了绘画功能. Affinity Photo 自带了较为丰富的画笔，并可以导入.abr画刷文件，同时，它提供了Surface Dial 的支持。 不过得提一句的是，在Surface Go等低配置设配中，Affinity Photo的画笔延迟很高，基本没法用。不知道是不是设置问题。 推荐分数：4.5 Autodesk SketchBook Autodesk SketchBook Windows Uwp版 在Windows/Mac这类桌面平台，SketchBook对比起CSP、SAI这些大佬级软件显得没什么存在感，然而放在移动平台上看，SketchBook却是数一数二的存在了。从截图也可以看出，SketchBook看起来就是专门为触屏设计。 在iPad 2018、iPad Pro、Samsung Galaxy Note、Surface Go等配有压感笔的移动设备中均有不错的体验。 不过在实际体验中，Surface Go配合SketchBook存在防抖修正有时失效的问题。 售价：免费 （Autodesk 家难得不要钱的 推荐分数：4.5 Sketchable 这个不算正式的推荐，但是如果你有Surface Pro、Surface Book或者Surface Studio的话，就一定得推荐体验一下Sketchable。如果有看过Surface Studio宣传片上的话，那个配合小旋钮（surface dial)的奇妙效果的东西就是Sketchable。 售价：免费（基础版本)/ 179元（Sketchable Premium） 推荐分数：4 Adobe Permiere ProAdobe Permiere Pro，也就是俗称的PR，是一个挺常见的视频剪辑软件。售价20.99美元/月 SONY Vegas 四年前版本的Vegas，现在的新版本因为Steam国区买不到了就索性没买，反正又不是不能用 说到剪辑软件，就不得不提Sony Vegas了。Vegas是个很出色的，拥有很多用户的视频剪辑软件，比如B站大多数（几乎所有）的鬼畜视频都是Vegas做出来的，中日韩的很多综艺节目基本上也是Vegas剪的。 不过Vegas很少会进入院校课程，因此对于大部份普通人来说，会有点陌生，提到视频剪辑软件只知道PR。（反正你们就认识个最贵的 实际上，对于大部份人来说，Vegas是一个使用过一次就会爱上的软件。 另外需要说明的是，Sony Vegas国内被某臭名昭著的版权流氓公司“代理”了，请尽量前往真正的官网或（ https://www.vegascreativesoftware.com/us/vegas-pro/ ）Steam（非国区）购买。注意：Vegas没有mac/Linux版本 官网售价：249美元 起（有多个售价版本 推荐分数：5 Final Cut Pro X 官网扒的图，因为这玩意我没买 Final Cut Pro X 和Vegas一样，一直以来就是和PR针锋相对的产品，也是Mac平台最佳视频剪辑软件之一。很多商业公司直接默认就是Mac + Final Cut Pro X的标配，所以虽然它也是Mac平台独占的，但并没有什么问题。 同样因为这玩意很少进入院校课程，对于大部份人来说有点陌生。 售价： 1998元 推荐分数：5 iMovie 实在没找到清晰的图，想了想，还是把mac掏出来截图了 iOS 版本 （iPad） iMovie是一个OS X系统和iOS系统自带的简单的视频剪辑工具，与Vegas之类的专业工具相比，iMovie更像是绘声绘影之类的玩具级剪辑工具（正式点说叫“家庭娱乐级别剪辑工具”，通俗点说：“又不是不能用”） 把这种玩具级软件放在“Adobe的替代品推荐”的文章里，看起来有点奇妙，主要还是因为很多人“不管什么用途的视频剪辑，你们就认识个最贵的PR”，我自己见到的就有很多了，明明是个小作业需要一段视频展示，就是简单的剪一剪配个BGM的事，就知道个PR，非要去下个PR，然后在各种奇妙配置的笔记本上艰难的跑着卡得跟什么似的PR。嗯 价格：免费 推荐分数：4 照片 Windows 10 1809 版本 照片 名字奇怪是奇怪了，它就叫照片我也没办法。这个是Windows 10 1803之后的版本自带的那个“照片”App里的视频剪辑工具。大体上功能和定位类似于上述的iMovie，属于“又不是不能用”的玩具级视频剪辑软件。但是反正常见的功能都有了，而且配乐、剪辑和导出流程都处理得很简单。 价格：免费 推荐分数：4 PS：为什么我不说绘声绘影呢，因为普通人买不到。国内被某个臭名昭著的著名版权流氓公司代理了，真正的官网不花点功夫还真搜不到。 DaVinci Resolve 达芬奇 免费版 这个就是传说中大名鼎鼎的“达芬奇”，你或多或少可能听到过有人装逼说：“PR什么辣鸡软件，真正的电影公司都用达芬奇”，说的就是这个软件。 达芬奇是个很强大的软件，但是为啥咱把推荐优先级放在最后呢，因为这个软件太强大且复杂了，上手难度高、而且绝大多数功能是普通人用不到的。（如果你工作中用得到这个软件，你根本不会去找“我来看看PR有什么替代品”）。但确实是不错的软件，得推荐一下。 达芬奇是在座的各位视频剪辑软件中唯一一个同时支持Windows / GNU Linux / Mac三个平台的。并且有免费版本。 售价：免费 / 299美元 推荐分数：5 Adobe illustratorAdobe illustrator，通常简称“AI”，也是美术人员的老朋友了。乍一看和PS有点像，区别是它俩中PS是负责位图（像素点阵图）的，另一个AI是负责矢量图的。 价格20.99美元/月 Affinity Designer Affinity Design , 官网下的试用版，这个大概率用不到我就没买 又看到Affinity了，Affinity Designer是Affinity系列的另一个软件。就好像AP是冲着PS去的一样，AD对应的就是Adobe家的AI。 实际上，矢量图这块我工作中基本用不到，对AI也不了解。我是看着Affinity Photo还挺不错之后，就把Affinity Designer安利给搞广告平面的朋友试了下。 得到的反馈总体好评，有优点也有不足，首先是不习惯（废话），然后其实快捷键和Adobe什么的比较类似，学习成本不算高。AD有三个模式切换，是挺好的功能 平时操作在设计角色（矢量图模式）下，如果需要处理已栅格化的东西，就需要切换到“像素角色”，然后就成了一个迷你版的PS。还有个“导出角色”是用来切片导出用的。 听起来好像很厉害，反正我仿佛听懂了，隔壁AI我听别人讲一遍我还是不会玩。 售价方面和Affinity Photo一样： Windows / Mac ：328元 永久 iOS：128 元 永久 插句题外话：我下载AD玩的时候发现它里面自带了一套UI素材，可是我平时工作中对接的各种UI他们用的都是PS啊，是不是游戏UI和别的行业的UI设计还不一样？有懂这个的大佬么求科普？ InkSpace类似于GIMP的形式，InkSpace也是个开源软件，专注于矢量图处理。 这个我还真用过，以前有个奇妙的甲方，让他们的平面设计师给我们出了一份UI设计稿，然后那个设计根本没做过UI，也不会切图。得，我寻思你要不把工程发我我自己来切吧，然后我就收到了一堆AI文件。当时不知道Affinity Designer，于是网上找了找发现有个InkSpace，下载下来试试吧。 至于体验的话，这么说吧：最后我把这软件删了去adobe下载了ai的试用版，然后告诉甲方：“在我试用版到期之前你可以改设计，14天之后就改不了了”。 具体的使用体验，有兴趣的自己下载了体验下呗。 Adobe FlashAdobe Flash曾经是互联网中重要的多媒体制作工具，小到网站小广告，大到页游，都能见到Flash的身影，曾经大红大紫的摩尔庄园、奥比岛等游戏就是基于Flash制作的。 如今Flash在Web领域基本已经消失了（国内奇妙环境除外），而在二维动画领域，Flash还是有着比较大的市场的，著名动画《罗小黑战记》、《潜行吧！奈亚子》、《大鱼海棠》等早期就是使用Flash制作，现在你仍然能在地铁、公交车上看到一些外包公司制作的公益广告是用Flash制作的。（据说山下清悟就是用flash把火影387话搞崩坏的 ） 当然也有些头铁的大佬会用PowerPoint之类的软件做二维动画，比如知名音乐《普通Disco》的mv 题外话：你甚至可以拿txt文档做个动画出来：https://www.bilibili.com/video/av237442 Web应用领域用途HTML5虽然看起来，HTML5是和Flash八竿子打不着的东西，但确实实时就是，Web领域中，HTML5干掉了Flash，如今的各种Web多媒体应用，都是基于或间接基于Html5制作的。 Unity 图为Unity 2019 如今的Unity更多是以游戏引擎的身份出现在众人的视野中，但实际上，Unity一直都没说自己是游戏引擎，而是“制作互动多媒体内容”的引擎。有些上了岁数的人可能记得，古时候第一个站出来挑战Flash在浏览器中的统治地位的，正是Unity。 古时候的Unity制作的网络内容，和Flash一样需要在电脑上安装一个播放器 图为一个早期的Unity媒体内容，提示要安装播放器（这东西甚至没法在大多数现代的浏览器上被打开 再后来，Unity搞了个WebGL模式，这玩意我们至今仍然能看到。 webgl的unity应用会常见这样一个加载页面（其实也是夕阳红技术 其实有个很有趣的事，最早搞Unity的不少人，就是从Flash的actionscript转到Unity的魔改版JavaScript的，（然后前两年Unity大刀部就把js支持整个砍了，求这群人心理阴影面积 Unity Tiny Mode (DOTS) 因为Unity家新搞出来的的DOTS一套和当前的Unity比起来实在是面目全非，我还是习惯于把它当成是两种不同的东西来说。 Unity Tiny Mode是基于Unity家新搞出来的DOTS技术的H5引擎，（要是非要问和现在的Unity有啥关系的话，只能说除了共用了一套编辑器，剩下的基本就是雷锋和雷峰塔的关系，卡巴斯基和巴基斯坦的关系） Unity Tiny Mode基于ECS设计框架，使用TypeScript 或C# 作为开发语言，制作的多媒体内容可直接输出为HTML/ CSS / WebAssembly的浏览器多媒体格式，现在常见的网页小游戏、小程序什么的，都是可以用Tiny Mode制作的。 LayaAir (LayaBox) Laya是伴随着移动端H5火起来的、主要针对HTML5的多媒体开发引擎（框架）以及一系列工具。而相对于Flash来说，Laya同样支持使用actionscript来编写逻辑（当然还支持js和ts） cocos： 那我呢？二维动画领域 (adobe animate)Retas可能接触学过多媒体专业的同学，学校教的都是Flash动画，这个adobe animate，其实也就是flash后来换个马甲。animate和flash，在欧美动画中挺常见，同时也是儿童电视动画的常客，据说超威蓝猫也是animate做的 那Retas又是个啥呢，Retas是来自CELSYS株式会社（ps: 其实CSP也是这个公司的）的动画制作软件，在国内除了“圈内人士”很少有人听说过，而在日本几乎是行业必备，你目前看的各种番大部份都是用这玩意做的。 （那为啥我会知道这玩意呢，因为我之前打算给自己独立游戏加个二维动画的片头和过场来着，然后去了解了一下，然后发现这玩意太xx专业了，根本玩不懂…… Clip Studio Paint（CSP）(怎么又是你) 就像我们之前介绍的，CSP是一个绘画软件，那它为啥又能做二维动画嘞，咱来看看中文官网的介绍： 动画这玩意嘛，本质上就是一堆连续的静态图片。有做过二维动画或者外包给别人做过二维动画的同学应该知道，动画这玩意都是按秒算钱的，一个游戏片头动辄几十万上百万，把声优的费用刨掉之后纯动画也得好几十万。它贵就贵在这儿了，你得一帧一帧的画这玩意。 “这和我认识的二维动画不一样啊，我学flash的时候，就做个矢量关键帧就好了啊，剩下都是flash自己补帧的呀。” 嗯，这就是为什么很多外包公司搞的flash动画看着就特别蠢的主要原因之一。 “可是我就是不想逐帧画咋办”，其实方法也多了去了。比如下面这个 Unity + Spine如果我们只想要那种很蠢的低成本二维动画的话，Unity + Spine倒是确实是个好选择。最简单的方法是先用Spine完成基础的东西，比如K动作、表情什么的，然后剩下的交给Unity 2017新出的大宝贝：Unity Timeline。 当然，Timeline原生只支持Unity自己的动画格式，是不支持Spine的，但是也不复杂，自己扩展一下就好了，写一个继承自 PlayableAsset的类，用于处理Spine的播放。 图片与实物无关.jpg 待续……","link":"/2019/06/20/e5-af-bb-e6-89-beadobe-e5-85-a8-e5-ae-b6-e6-a1-b6-e7-9a-84-e6-9b-bf-e4-bb-a3-e5-93-81-e3-80-90-e9-95-bf-e6-9c-9f-e6-9b-b4-e6-96-b0-e3-80-91/"},{"title":"怎么理解游戏热更新中的“母包”和“补丁”","text":"我们玩过游戏的都有过这样的经历，一个游戏安装好之后，啥都不用管，每次点开游戏之后读个条，游戏内容就始终是最新的，可能有新的道具、新的活动，可能某个东西过些日子就找不到了。 当我们学过怎么做游戏之后，我们就知道，哦这玩意叫热更新。那么热更新到底是怎么更新的呢？ 在传统的win32或者gnu linux中，我们要热更新一个软件或者游戏是非常方便的，因为它们本质上就是一堆文件堆在那儿，点两下就能运行，哪个有变化就更新哪个，完事。 但是在更多的平台上，我们是不能这么任性的，比如说在Android中，我们一个apk安装好一个App上去，这个App就是把屋顶都拆了也没法自己修改自己，你只能用一个新的apk文件来替代它。 而现代很多系统平台，什么uwp啊，iOS啊，xbox啊，都是采用了类似的软件包的设计形式。 那么就有问题了，照理说，这种机制下，我们的软件没法修改自己，那就没法实现热更新啊，怎么办呢，伟大的劳动人民总是心灵手巧的，人们发现：虽然我没法修改自己，但是在很多系统里面，我都可以申请一块存储空间来读写着玩。那，好像是不是可以曲线救国一下呢？ 于是出于这种种原因，现代的很多App啊，游戏之类的，就演变出了这么一种热更新思路，首先，我们可以在概念上，把整个App拆成两个部分： 基础部分：底层的、不会经常变动的部分。 业务部分：基于基础部分之上的，变动频繁的部分。 通常，这个基础部分是无法热更新的，如果要修改这部分，就得重新制作安装包给应用商店。而业务部分，则是可以被热更新的，而通常负责业务部分热更新功能的，正是基础部分。 其实每次说到这个部分的时候，我就会想到网页浏览器。我也很喜欢用网页浏览器来作比喻：这个基础部分就是个浏览器，而业务部分就相当于是我们平时浏览器里的网页。这个浏览器在我们本地可能万年不更新，但是每次刷推特刷新闻都能立即看到最新的内容。 当然，其实这也不完全是比喻，比如PWA和某些“所谓的小程序”，就真的是浏览器和网页。 当我们理解了这个部分之后，我们就来进入正题了，在现在很多游戏领域有两个概念：“母包”和“补丁”。从玩家角度来看，大家可能都知道补丁是个什么东西，但是对于母包这个词就有点陌生了，那么母包和补丁包的关系到底是怎样的呢，我们来举个栗子： 比如说，我们在做一个游戏，做着做着，好像差不多了，欸我们发布给用户玩玩吧，怎么发布呢，就是正常的把游戏编译出一个安装包。就比如说是个apk包吧，我们把这种完整的安装包，就称为母包。为了方便描述，我们把这个母包称为“母包1”，这时候的客户端版本，记作1.0 比方说我们的母包1包含了这么些东西 然后，我们把这个1.0客户端给放在了应用商店，提供给用户下载使用。 但是，虽然我们发布了一个版本，但是开发并没有停止，我们还是不断的在往游戏里加新东西，那么到了第二天，我们改动了这么些东西： 我们在昨天的1.0版本的基础上，修改了一个文件，又增加了一个文件。这时候，我们希望我们的玩家的游戏，都同步到这个新版本来，怎么办呢？ 最传统的方法就是我再编译一个安装包，扔给应用商店。但是这样做就有问题了，比如说啊，我一个安装包有10个G，但是我就修改了10kb的内容。你说你要是每天更新一次，每次都让玩家下载10个G的安装包，估计玩家四十米的大刀就收不住了，没过几天玩家全跑了没人玩了。那怎么办呢，这时候，就该补丁包出场了。 我们制作了一个补丁包，把我们今天变动的两个文件单独拧了出来，丢在我们的服务器上。然后玩家的客户端会自动下载这个补丁文件，把这两个改动的文件更新到原来的客户端中。 这样一来，玩家手里的客户端就是今天的最新版本了，为了方便说明，我们把这时候的客户端版本记作*1.1 * 客户端1.1 = 母包1.0 + 补丁1 好的，我们的故事还在继续，第三天，我们又修改了一些内容，变成了这样： 然后我们现在又想把这个最新版本同步更新给玩家了。在刚刚第二天是时候，我们发现补丁包是个好东西，于是到了第三天这里，我们自然而然的就想到了：欸我们再打个补丁吧，就叫补丁2吧 思路没错，但是要注意的是，这里我们有两种方法来做这个补丁2 方法1：我们把相对于1.0版本客户端的所有变动的内容，都放在补丁2中 这时候，比如说有个玩家，第一天下载了我们的游戏，版本是1.0，第二天这个玩家没玩，也就没更新成1.1，这时候当他第三天打开我们的游戏之后，游戏只需要直接下载补丁2，就可以把客户端变成最新版本了（记作1.2版本） 但是对于客户端版本是1.1的玩家，这时候就不爽了：“你这个补丁2里有三分之二的文件，我昨天都已经下载过一遍了，这又让我把整个文件下载一遍什么意思，我流量不要钱啊” 方法一中：版本1.2 = 母包1.0 + 始终最新版本的一个补丁 方法2：我们在补丁1（版本1.1）的基础上，制作补丁2（版本1.2） 这时候，我们当前版本为1.1的玩家，只需要下载一个相对方法1中体积更小的补丁2，就可以把客户端变成最新的1.2版本了。 而版本在1.0的玩家，就得按照顺序，先下载补丁1，把自己变成1.1版本，再下载补丁2，把自己变成1.2版本。 至于说这两个方法哪个更好，其实没有明确答案。这两个方案各有优缺点，也都是被广泛使用的方法。 方法2中，版本1.2 = 母包1.0 + 补丁1 + 补丁2 （依次） 好的，到这一步，我们大概算是明白，母包和补丁之间的关系了，但是还没完，我们的例子继续进入下一步。 第四天，我们没有修改任何东西，但是我们重新编译了一个安装包，记作母包2 欸，我们发现了，这个母包2中的内容，和之前母包1加两补丁的1.2版本的内容是一模一样的。 如果这时候，我们把母包2放在应用商店中给新来的用户下载，那么下载了母包2的用户打开就直接能玩了，不需要再下载补丁来更新客户端。而与此同时，之前下载了我们母包1，并且通过补丁更新到1.2版本的玩家，也不需要重新去下载一个母包2，就可以获得一致的游戏内容。 也就是说： 母包、补丁包和客户端版本之间的关系并不是一一对应的。 补丁包是依托于某个特定的母包版本的。不能说我母包2去下载个母包1的补丁，那就乱套了。 （当然，也有那种补丁包不依赖于特定母包版本的骚操作存在，但那就是另一个故事了） 题外话，我们一开始把游戏分为基础部分和业务部分两个部分。对于很多游戏来说，会把javascript、lua、python这些语言代码文件放在业务部分，这样一来，游戏中的绝大部分业务内容就都可以实时更新了。 讲到这一步，对于我们大部分中小团队来说，就完全够用了，那么，看完之后要不要试试看活学活用，自己动手给自己的App/游戏实现一下热更新的功能呢。","link":"/2019/08/06/e6-80-8e-e4-b9-88-e7-90-86-e8-a7-a3-e6-b8-b8-e6-88-8f-e7-83-ad-e6-9b-b4-e6-96-b0-e4-b8-ad-e7-9a-84-e6-af-8d-e5-8c-85-e5-92-8c-e8-a1-a5-e4-b8-81/"},{"title":"我，博客，改动","text":"在自己都受不了之前的博客的疯狂卡顿之后，终于决定给它改改了。 首先，前端风格改成了https://mkm.st/ 的开源主题，原来的前端UI有引用一些海外的字体导致疯狂卡顿。 然后，域名变了！ 域名由zerorstudio.com改成了yomunchan.moe. 感觉前者域名怎么看都不像是个个人博客的域名。至于yomunchan似乎还是有点长了。但是好像也想不到怎么起个更短的（而且不贵）的域名。 目前zerorstudio.com域名还是可以继续访问的，到2019年左右会停止解析。 之后，为了解决卡顿的问题，忍痛重金给加了几个国内的CDN，还升级了下服务端缓存机制。（好像确实访问速度上有点效果了） 顺手呢，给做了个静态镜像站，托管在GitHub Pages上了 emm，日常下定决心好好打理一下博客，然后，日常忙忘了。也不知道忙啥，额。","link":"/2018/12/18/e6-88-91-ef-bc-8c-e5-8d-9a-e5-ae-a2-ef-bc-8c-e6-94-b9-e5-8a-a8/"},{"title":"新年快乐2019","text":"☆彡(^･ᴗ･^) 新年快乐啊各位，新的一年，大家要变得更厉害哦","link":"/2019/02/04/e6-96-b0-e5-b9-b4-e5-bf-ab-e4-b9-902019/"},{"title":"手动配置Unity/Android开发环境（Windows）","text":"自从有了Unity Hub之后，Android 开发环境的配置变得非常简单，你几乎什么都不用管，在Unity Hub里点三个勾就完事了。 但是，令人不愉快的是，并不是所有的情况下Unity Hub的安装方式都会起作用（比如当你想安装一个指定版本的Unity Editor而Unity Hub并没有提供这个版本下载的时候）。这时候就得手动配置Android开发环境了。 Unity 下的Android开发环境基本上与原生开发无异，首先是Java的JDK环境，然后是Android 的SDK，由于要处理Cpp，所以还有一个NDK环境。 但是问题来了，JDK和Android SDK和Unity之间的版本的各种关系非常混乱，（比如Android SDK目前无法在JDK13版本下工作）。 所以这里介绍一个讨巧的方法。 首先，利用Unity Hub安装一个Unity Editor.比如说，我们团队统一了Unity的版本是Unity 2019.2.0f1 但是通过Unity Hub安装我们会发现，Unity Hub只提供了Unity 2019.2.x的最新版本，并没有Unity 2019.2.0f1 所以当我们需要使用Unity 2019.2.0f1时，只能从官网安装，但是官网安装的编辑器是没法通过Unity Hub来添加Android环境组件的。 那就没办法了，直接先安装Unity 2019.2.8f1（当前同版本号2.x的最新版本）（尽量安装大版本号一致的版本） 安装好之后，我们就能看到“添加模块”这个选项了。 用Unity Hub安装一个Android 环境这一步简单了，直接在刚才安装好的版本的Unity Editor中勾选这三个模块，等待Hub安装完成。 然后，复制大法只要是通过Unity Hub安装了Android环境的版本，我们定位到安装路径下的这个路径：Editor/Data/PlaybackEngines/AndroidPlayer 然后我们就看到我们需要的几个环境了，接下来，把NDK，OpenJDK，SDK三个目录直接复制到我们需要的引擎版本的安装目录的相同位置。 然后我们发现Unity直接自己识别出来了，可以说是非常省事了。 （ps：其实我没复制OpenJDK目录，但是编辑器也识别出来了，估计Unity可以共享这个吧，但是NDK和SDK是不行的。） （后续发现，OpenJDK还是得拷过去，不然会出问题）","link":"/2019/10/07/e6-89-8b-e5-8a-a8-e9-85-8d-e7-bd-aeunity-android-e5-bc-80-e5-8f-91-e7-8e-af-e5-a2-83-ef-bc-88windows-ef-bc-89/"},{"title":"瞎折腾：用Unity撸纯HTML5移动游戏/应用","text":"这两天灵机一动，大概折腾了个demo （ps: 博客站的CDN在墙外（HK），如果刷不出图的话，请尝试改变一下上网方式。） 效果上有点像Unity自己家的Project Tiny那样，Build之后得到的是一个纯HTML5的前端应用。 不过不同于Tiny，我们这里设计的还是相对传统的GameObject+组件这种开发方式：场景-&gt;GameObject-&gt;组件，而非DOTS那套。 使用GameObject 挂在组件的方式编辑场景，编写C#代码，并在构建时导出HTML应用。 因为暂时没打算把它做完，就压根没往GitHub上整，大概写点东西 算是记录一下： 首先是大概思路： 这玩意其实相当于是一个独立的引擎或者说框架了，和Unity的Runtime基本上没关系。目前大体上可以分为两个部分： 一个是核心模块(core)，这部分是一个独立的、与Unity无关的独立工程，由C#和TypeScript编写。在核心模块中，有一套重新实现的GameObject和Compoment的机制。核心模块可以直接用来编写业务逻辑并构建HTML应用，不需要编辑器。 直接用core部分编写业务 另一个部分就是针对Unity的扩展，把core部分的东西和Unity关联起来。 在应用构建时，Unity的扩展部分会把在编辑器中编辑的场景、Prefabs等内容读取出来，存储成Json放进HTML应用的资源中，（我们暂时在HTML应用中把Scene、Prefabs什么的都统称为Stage），然后在浏览器中运行时，Core会把各种GameObject根据JSON加载出来并挂在Components，由Core来维护整个应用的生命周期，并把需要显示的内容绘制在Canvas上。 所以，虽然说是用Unity开发HTML应用，但基本上和Unity本身没啥关系了，只是借用到了Unity的编辑器。而在应用运行时，就是个单纯的HTML应用了，就没Unity的事了（其实Tiny之前还是TypeScript的时候也是这么干的，现在不清楚，还没细看过它的实现） 也正是因为上述的原理，所以我们在实际写业务逻辑的时候，需要把我们的业务代码和Unity的内容（UnityEngine命名空间等）明确的分隔开。同理，在编辑场景的时候，我们也不能挂载Unity提供的组件（目前Unity的Canvas等几个组件除外，导出的时候会自动忽略）。 也就是说，MonoBehaviour也是不能用了。我们自己实现了一个Behaviour类，用宏定义符号做了分隔：在编辑器下，继承自MonoBehaviour，以便我们在编辑器下挂在组件和调试。而在构建HTML应用时，MonoBehaviour部分的东西就会被剥离，由Core来管理这些组件。 重新实现的Lable组件（demo阶段，所以功能贼少） （在编辑器中调试这件事，目前的设计是用宏定义在编辑器下继承Unity的组件，比如目前的Lable在编辑器下会继承自UnityEngine.UI.Text，这样做的目前的借用Unity的Runtime来调试应用，另一方面可以直接用Unity直接的方式构建App。当然目前这个想法有没有什么坑还不知道，还没往下深入的做，没遇到坑暂时。） 浏览器里运行C#的问题： 折腾这玩意，最根本的目的是我想用C#写HTML5应用玩。所以浏览器里跑C#的问题就一定得解决了。 常见的方法有两种，一个是WebAssembly，另一个是把C#翻译成JavaScript. 权衡了各种因素，目前的实现的demo中选择了后者，我们在构建应用时把C#翻译成了JavaScript. （但其实直到现在对于两者的选择还是摇摆不定） 这里使用了开源项目Bridge.NET来实现这个功能。 把C#翻译成JavaScript在目前最大的好处是包体极小，兼容性较好，GC什么的问题也不大。","link":"/2020/02/01/e7-9e-8e-e6-8a-98-e8-85-be-ef-bc-9a-e7-94-a8unity-e6-92-b8-e7-ba-afhtml5-e7-a7-bb-e5-8a-a8-e6-b8-b8-e6-88-8f-e5-ba-94-e7-94-a8/"},{"title":"解决Unity的网络水土不服问题","text":"嘛，是这样的，Unity在使用Package Manager等工具时，有时候会下载不下来东西，然后卡死。这是怎么回事呢 首先，通过询问官方，我们知道，目前Unity Package Manager主要会访问这么几个地址 packages.unity.com download.packages.unity.com dl.bintray.com api.bintray.com akamai.bintray.com 但是，最下面三个，在大陆访问是不通畅的，而比如Tiny Mode啊、ECS Framework啊这类的包，都是放在这个上面的， 那怎么办呢，用梯子呗。 众所周知，现在的梯子大概两种，一种是VPN这种直接把整个网络通道都覆盖掉的，另一种是以影梭为主的，默认只会代理HTTP/HTTPS的， 而问题在于，影梭的代理，是只修改系统的浏览器默认设置。而Unity默认又不会读取浏览器的代理设置。简单的说，它不吃ss/ssr的梯子。 那怎么办呢，其实也简单：我们从环境变量下手好了。 windows下，写一个.bat脚本，内容如下： @echo off set HTTP_PROXY=http://127.0.0.1:1080 set HTTPS_PROXY=http://127.0.0.1:1080 start &quot;&quot; &quot;C:\\Program Files\\Unity Hub\\Unity Hub.exe&quot;注意这地方，HTTPS的设置value也是“http://xxxx”,而不是&quot;https://xxxx&quot; mac下，脚本如下 echo &apos;#!/bin/bash export HTTP_PROXY=proxy-url export HTTPS_PROXY=proxy-url nohup &quot;/Applications/Unity Hub.app/Contents/MacOS/Unity Hub&quot; &amp;&gt;/dev/null &amp;&apos; &gt; launchUnityHub.command chmod +x launchUnityHub.commandLinux下同理 然后我们来看看原理，首先，用脚本设置环境变量，为什么在脚本中设置呢，因为很多人梯子是不稳定的，一直开着会影响网络的稳定性。而如果你直接在系统窗口里设置环境变量，而梯子没开的话，所有用到这个环境变量的程序都会网络异常。 所以我们在脚本中设置它，然后，启动Unity Hub，这时候Unity Hub就已经在代理下运行了。这时候通过Unity Hub启动Unity Editor的话，Editor下的一切都是走在代理上的。","link":"/2019/05/16/e8-a7-a3-e5-86-b3unity-e7-9a-84-e7-bd-91-e7-bb-9c-e6-b0-b4-e5-9c-9f-e4-b8-8d-e6-9c-8d-e9-97-ae-e9-a2-98/"},{"title":"Git（TortoiseGit）项目合作时的各种坑","text":"Git项目合作时的各种坑 一、文件冲突 拉取远端内容时弹出如下： 这堆英文怎么理解呢，如下： 也就是说，file1.txt这个文件冲突了。 文件冲突，一般是指远端的这个文件与你本地的这个文件内容不一致，而且多半无法自动合并更新的。 这时候，最安全的做法是：放弃本地修改，采用远端版本的内容。 这么操作的最后效果是： 比如说远端文件内容是“aaa”,本地的内容是“bbb”,最终放弃bbb，把本地的变成aaa（保持一致） 怎么操作呢，标准方法如下， 右键工程根目录，选择“检查已修改” 右键冲突的file1.txt，选择还原。 然后再重新拉取远端的内容 二 、 文件冲突 （第二种情况） 这种情况下，假设我们不知道远端文件有更新，修改并提交了本地的文件（注意，是提交，不是推送） 这时候我们拉取远端文件 报冲突如下： 这时候可以右键冲突的内容，解决冲突 然后下面是重点，请仔细阅读 当我们再次提交的时候，这是一个合并提交，“因为包含您的更改和已合并树的更改” 在真实情况下，这里默认会勾选很多你没见过的或者没动过的文件。“您不应该取消选中任何文件，除非您明确知道这是在做什么” 如果你取消选中了某个文件，那么它将不会存在于新的版本分支中，也就是说，系统会认为这个文件没用了，删掉了","link":"/2018/11/11/git-ef-bc-88tortoisegit-ef-bc-89-e9-a1-b9-e7-9b-ae-e5-90-88-e4-bd-9c-e6-97-b6-e7-9a-84-e5-90-84-e7-a7-8d-e5-9d-91/"},{"title":"[Golang]搭建一个VSCode “够浪”的开发环境","text":"开篇吐槽：Goland太贵了！所以我要用VSCode! 首先，当然是先安装Golang了呀，然而由于Golang是Google的产品，在国内是无法直接访问Golang的官网的（https://golang.org）。但是还有个Google在国内特地弄的一个镜像官网可以用：https://golang.google.cn/ 早就想买个电脑跑Linux的，但一直没舍得，所以我就只能选Windows版本了嘛 安装过程就不赘述了，标准的Windows安装包嘛，安装好了之后，就开始配置工作环境吧。 第一步，找个喜欢的位置，建立好工作目录 比如酱紫 在工作目录下新建一个文件夹“bin”，就像这样 目录大概就建好了，现在我们把目录相关的东西添加进环境变量。 右键“此电脑” -&gt; “属性” -&gt; “高级系统设置” -&gt; “环境变量” 就像这样喵 个人喜欢，把配置放在用户变量里，当然，放用户变量里还是系统变量都行 首先，在Path项中加一条路径，也就是我们刚刚建立的工作空间里的bin目录 因为Golang环境下有些工具会被编译到这个目录下，添加到PATH环境变量之后我们就可以在命令行里使用这些东西了。 然后，如果之前安装Go的安装包的那一步很顺利的话，我们可以在用户变量中看到它自动添加了这一条： GOPATH应该指向我们的代码工作空间 我们把这个路径改到我们一开始创建好的工作空间中。 就像这样 然后我们新建一个叫GOBIN的变量，同样指向我们工作空间目录下的bin目录 我们刚刚安装的时候，安装包自动给我们创建了一个叫GOROOT的环境变量，这里指向的是Golang的安装路径，通常不用管它就好 最后，重启一下电脑，让相关的配置生效 然后，就开始折腾VSCode的部分了。 首先，用vscode打开我们的工作目录。 第一件事，先装上微软家开发的这个叫Go的扩展插件 然后，建立src目录，以后所有的代码工程就都放在这里了 我们在src下面随便建立一个xx.go的文件，然后随便打几个字（最后记得把这个文件删掉）之后，我们发现，VSCode的右下角弹出了一堆弹窗 随便点其中某个Install All 开始安装这个扩展所需的各种插件工具。 不过，很遗骸，由于“大清自有国庆在”等原因，我们没法很愉快的完成安装。 有几个安装成功了，不过大部分都安装失败了 所以接下来就是重点了 首先，在src目录下建立“golang.org/x”目录 然后把 https://github.com/golang/tools 这个仓库clone进去 顺便把 https://github.com/golang/lint 这个仓库clone进去 大概就是这样 然后挨个安装之前没安装成功的东西 go install github.com/mdempsky/gocode go install github.com/ramya-rao-a/go-outline go install github.com/acroca/go-symbols go install golang.org/x/tools/cmd/guru go install golang.org/x/tools/cmd/gorename go install github.com/stamblerre/gocode go install github.com/rogpeppe/godef","link":"/2019/01/22/golang/"},{"title":"把一个UE4工程里的C++全删掉","text":"讲真，这绝对是个非常奇葩的需求，我在网上都找不到有人这么干的，怎么把UE4工程里的C++代码全删掉。首先，先把UE4编辑器和VS都关了，然后去项目目录删掉这两个东西： Binaries目录 Source目录 然后，这时候再打开工程，我们会看到这个玩意： ) 然后恭喜，你的工程就成功的打不开了。 然后我灵机一动的想了想，接下来这么解决。使用除了notepad.exe之外的文本编辑器打开项目的.uproject文件。 然后我们发现，这个文件实际上是用JSON格式写的。 把上图红框框里的那个数组删了，然后保存，心中默念三声“fuck epic”，然后打开工程，好了。 （当然，如果你的工程里C++和Blueprint高度耦合的话，你需要提前给代码处理干净，否则就恭喜，你的工程真的彻底打不开了，真的。）","link":"/2018/05/27/howtodeleteallcppcodeinue4/"},{"title":"Orleans 最佳实践","text":"内容来自于微软的官方文档 https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/Orleans20Best20Practices.pdf （可能有点旧，是三四年前的资料了）（但是中文领域没找到，我就给搬过来了） Scenarios &amp; General Fit什么时候我们需要试试看Orleans 拥有大量（成百上千万的）低耦合的实体 实体足够小到可以在单一线程上完成工作 以“请求–响应”或“启动–监测–完成”的交互方式工作的 需要或可能需要在不止一台服务器上协同工作（集群） 一次只需要在几个实体之间进行协调工作，而不需要整体的协调工作。 在不同事件使用不同的实体。（视具体情况） 不适用于以下情况 实体需要直接去访问彼此的内存。 数量少，但是单体庞大的、需要在多线程下工作的实体 需要整体的协调和一致性 长期一直运行的操作、批处理或SIMD（视具体情况） 设计Grains Actor 并不是平时理解的Object , 尽管它们非常相似。 低耦合、基本独立 独立于其他的Grains去封装和管理它们的状态。 可以单独出故障（自闭可以，但不要影响其他Grains继续工作） 避免Grains之间有频繁的交流 消息传递相较于直接访问内存的方式，性能开销的代价要大得多 如果两个Grains之间一直有频繁的互调用，也许应该考虑是不是应该把它两设计合并成一个Grains 要考虑参数的尺寸和复杂度，以及序列化问题。 有时候，重发一个二进制消息并反序列化两次的开销是比较小的。 避免Grains的瓶颈 单一的调度者、登记处或监测器 如果有必要的话，进行分段的聚合 实现Grains —— 异步 一切都应该是异步的（TPL），不要有堵塞线程的操作 最佳的实践机制是 async/await 经典案例：返回一个具体的值： return Task.FromResult(value); 返回一个同类型的Task return foo.Bar(); await 一个 Task之后继续执行点什么 var x = await bar.Foo(); var y = DoSomething(x); return y; Fan-out: var tasks = new List(); foreach(var grain in grains) tasks.Add(grain.Foo()); await Task.WhenAll(tasks); DoMore(); 实现Grains什么时候使用**[StatelessWorker]** 功能操作： 解码、解压缩，然后转发处理 多次激活，并且总是在本地的 比如：良好的分段聚合（首先在本地，不在Silo中） 默认情况下，Grains是不可以重入的（意思应该是不可以递归） 在调用周期中会出现死锁， 比如调用自身 死锁会因为超时而自动中止。 使用[Reentrant]属性（attribute）来使一个Grain类可重入。 重入将依然是单线程下的，但是可能会交叉。 处理交叉问题容易出错。 继承 继承一个Grain的接口（interface）是简单的 当多个Grain类继承了相同的接口时，可能需要消除歧义。 Grain类的继承是有限的 持久化声明会中断继承 泛型是被支持的 关于Grains持久化的概述Orleans的Grain的状态持久化API被设计用来提供易于使用的可扩展的存储功能。 Grain的状态持久化 定义一个接口（interface）继承自Orleans.IGrainState, 并在该接口中包含Grain里需要持久化的字段。 Grain类需要继承 GrainBase&lt;T&gt; 并在Grain的基础类中添加强类型State字段","link":"/2020/01/03/orleans-e6-9c-80-e4-bd-b3-e5-ae-9e-e8-b7-b5/"},{"title":"Raspberry Pi 3B+系统安装完全详解","text":"这是一个写给完全没接触过RaspberryPi（树莓派）的读者。 树莓派是一个结构完整的微型硬件开发板，我们先别管上面这句话是什么意思，先这么理解：这是一台特殊的小电脑。好了，那么这篇文字要说的就是，怎么给这个小电脑装上一个操作系统。这是使用树莓派的第一步。 准备工作在开始给它安装系统之前，我们需要准备一些其他的东西。如果你只有一个光秃秃的树莓派开发板的话，那么很高兴的通知你，你玩不了。本着尽可能避免“让对电脑不熟悉的人看不懂”，在介绍准备工作的时候，我就尽量避免介绍具体的型号和参数了。如果你觉得这个写的太简单了不适合你，欢迎出门右转到“树莓派实验室http://shumeipai.nxez.com” 准备一个100块钱以上的读卡器。 2. 准备一个150块钱以上的金士顿或者闪迪牌的储存卡。大小的话就是插MP3里那么大的那种 3. 准备一个50块钱以上的HDMI视频线 4.准备一个不是三星牌的显示器 5.准备一套随便多少钱的键盘和鼠标，要USB接口的 然后，树莓派官方推荐的操作系统叫”Raspbian”，是一个Debian的魔改版。这里的话，我不怎么喜欢这个系统，而我比较喜欢“Ubuntu”，所以就去准备一个Ubuntu的img镜像文件。 Ubuntu 可以从这里下载，选择适合树莓派的版本：ubuntu-mate.org （如果打开网站不知道在哪下载的话，就把网站上每一个字都读一遍，读出声，读完了还不知道的话就再读一遍。） 此外，还需要一个SD卡格式化工具SD Formatter 和镜像写入工具USB Image Tools USB Image Tools: 点击下载 SD Formatter: 点击下载 开始安装首先，从Ubuntu官网下载的系统是一个.xz的压缩文件格式 我们可以使用7zip或者Bandizip工具将其解压成Img格式文件。注意不要使用好压、360压缩和快压。 然后将储存卡插入读卡器，使用格式化工具SD Formatter将其进行格式化。 然后打开USB Image Tool，选择SD卡设备。 点击“Restore”，选择刚才解压好的img格式文件。 ) 然后静静的等待它安装镜像就可以了。 安装好之后，这个系统就做好了，那么是不是就可以开机了呢，倒也不是，还差一个重要步骤——设置屏幕分辨率。 在安装完镜像之后，我们发现，SD卡被分成了两个分区，其中有一个特别小的叫“PI_BOOT”，还有一个打不开（就应该打不开，也不要强行打开）。 在PI_BOOT这个分区的根目录下，有一个叫config.txt的文件，这个就是树莓派的硬件配置文件（类似于家用电脑主板的BIOS） 使用Notepad++、sublime Text、VIM、gedit之类的专业文本编辑器打开它，不要使用记事本之类的。 在任何空白位置输入两行文本： hdmi_group=1 hdmi_mode=16 这个是针对HDMI 、1080p 60hz的显示器的设置。 设置完成之后保存，弹出SD卡，并插入树莓派，开机。 ———————————— 插上键鼠和显示器，稍等片刻，就会看到熟悉的Ubuntu风格的界面。 首先是语言选择， 然后注意这里是选择时区不是地区！默认是上海就对了，不用改别的。 然后是键盘设置，如果你不懂这个选项是干嘛的，默认选择“英语（美国）”，不要选别的东西。 最后设置用户信息，安装完成。 做点更好的首先第一步，按ctrl+alt+t呼出终端，养成一个习惯，新系统的第一个命令应该是 sudo apt update 为了这个东西单独独占一套键盘鼠标倒是还行，但是为一个一两块块钱的板子，耗一个几千块钱的显示器就划不来了。 所以我这里其实使用的是台式机的显示器，也就是说我不可能总把显示器插在上面的。那么就有了一个需求，我能不能通过网络去远程访问这个。 所以，我们来安装一个小东西，在终端下运行 sudo apt install xrdp 然后就可以使用Windows的远程桌面管理工具登录了。 ) 大功告成，尽情享用Ubuntu和树莓派","link":"/2017/12/05/raspberry-pi-3b/"},{"title":"TinaX Framework 自动化构建实践","text":"刚才有小伙伴问，TinaX在构建母包之前都得手动打包资源，那么如果要放在DevOps工具中，应该如何让它自动打包呢？ 其实这个不是什么复杂的事情，我们自己的项目中一直在使用Unity Cloud Build Service来自动化构建TinaX项目。而实现这一点也只需要自己在工程中写一个脚本，让其在执行构建之前运行，自动执行一些准备操作即可。 那么，直接贴代码如下： using UnityEngine;using TinaXEditor.VFSKit;using TinaX.VFSKit; namespace ExampleEditor{ public static class CloudBuildHandle { /// &lt;summary&gt; /// 处理iOS的编译 /// &lt;/summary&gt; public static void Build\\_iOS\\_Handle() { var xPlatform = TinaX.Const.PlatformConst.E_Platform.iOS; var uPlatform = UnityEditor.BuildTarget.iOS; Debug.Log(&quot;开始 云编译前置处理工作&quot;); // 加一个步骤，生成Xlua代码 Debug.Log(&quot;清理Xlua代码&quot;); CSObjectWrapEditor.Generator.ClearAll(); Debug.Log(&quot;重新生成Xlua代码&quot;); CSObjectWrapEditor.Generator.GenAll(); //第一步，打AB包 Debug.Log(&quot;资源打包工作&quot;); var packPath = $&quot;{TinaX.Setup.Framework\\_AssetSystem\\_Pack_Path}/{xPlatform.ToString().ToLower()}/&quot;; var packer = new XVFSPacker(); //构建一个打包对象 packer.AddPackPlan(new VFSPackPlan() //添加打包计划 { Platform = uPlatform, XPlatform = xPlatform, ClearOutputFolders = false, //反正云构建有Clear选项 CopyToStreamingAssets = true, //这儿直接会复制进去，就不需要手动操作了 OutputPath = packPath, AssetCompressType = VFSPackPlan.CompressType.LZ4 }); //开始打包 packer.StartPacker(TinaX.Config.GetTinaXConfig&lt;VFSConfigModel&gt;(TinaX.Conf.ConfigPath.vfs).GetPerfect()); Debug.Log(&quot;流程执行结束&quot;); } }} 如果使用TinaX 6.4.x及以前版本，处理代码如下（有点乱）： using System.Collections;using System.Collections.Generic;using UnityEngine;using TinaXEditor; namespace ExampleEditor{ /// /// 云编译系统处理 /// public static class CloudBuildHandle { //要处理其他平台的话，直接复制一份改，不要做封装 /// &lt;summary&gt; /// 处理windows64的编译 /// &lt;/summary&gt; public static void Build\\_Windows64\\_Handle() { Debug.Log(&quot;开始 云编译前置处理工作&quot;); // 加一个步骤，生成Xlua代码 Debug.Log(&quot;清理Xlua代码&quot;); CSObjectWrapEditor.Generator.ClearAll(); Debug.Log(&quot;重新生成Xlua代码&quot;); CSObjectWrapEditor.Generator.GenAll(); //第一步，打AB包 Debug.Log(&quot;资源打包工作&quot;); var packMgr = new AssetPackageMgr(); var packPath = TinaX.Setup.Framework\\_AssetSystem\\_Pack\\_Path + &quot;/&quot; + TinaX.Const.PlatformConst.E\\_Platform.Windows64.ToString().ToLower() + &quot;/&quot;; Debug.Log(&quot;资源打包路径：&quot; + packPath); packMgr.PackGlobal(packPath, TinaX.Platform.GetBuildTarget(TinaX.Const.PlatformConst.E_Platform.Windows64), true, true, false, false, true); //执行复制流程 var pathInStreamingAssets = &quot;Assets/StreamingAssets/vfs/&quot; + TinaX.Const.PlatformConst.E_Platform.Windows64.ToString().ToLower(); Debug.Log(&quot;执行移动流程，从&quot; + packPath + &quot; 到 &quot; + pathInStreamingAssets); var target_path = System.IO.Path.Combine(System.IO.Directory.GetCurrentDirectory(), pathInStreamingAssets); System.IO.Directory.CreateDirectory(System.IO.Directory.GetParent(target_path).ToString()); Debug.Log(&quot;新建目录：&quot; + System.IO.Directory.GetParent(target_path).ToString()); System.IO.Directory.Move(System.IO.Path.Combine(System.IO.Directory.GetCurrentDirectory(), packPath), target_path); Debug.Log(&quot;流程执行结束&quot;); } }} 之后，以Unity Cloud Build Service为例，在Build Config的 Advanced Options 中，将之前写好的代码填入 Pre-Export Method选项中，格式为“命名空间.类名.方法名”，如 ExampleEditor.CloudBuildHandle.Build_iOS_Handle 同样的，在Jenkins中，我们也可以使用类似的方法，在命令行启动Unity的时候启动对应的处理脚本。 注意：2019年10月7日，Bug修正：在TinaX 6.5.x的案例代码中，我们通过TinaX.Config.GetTinaXConfig(TinaX.Conf.ConfigPath.vfs) 这一行代码拿到TinaX VFS配置文件的对象。 这个写法之前是没问题的，但是在TinaX6.5.x中，我们拿到的这个配置文件是不完整的——它只有开发者自己的配置。而实际上TinaX内部也会有一个写死的配置文件，比如在我们使用Lua时，TinaX需要将自己内部的Lua代码一起打包。 而如果直接使用TinaX.Config.GetTinaXConfig(TinaX.Conf.ConfigPath.vfs) 传给XVFSPacker的话，XVFSPacker就只会对开发者定义的部分资源进行打包，而忽略了框架内部的资源，这样打出来的包就会缺失部分资源导致无法使用。 所以需要改成如下写法 TinaX.Config.GetTinaXConfig(TinaX.Conf.ConfigPath.vfs).GetPerfect(); 后面多出来的.GetPerfect()是一个扩展方法，将框架内部定义的配置与开发者定义的配置合并之后，返回合并后的结果。 除了扩展方法之外，还有另一种写法: using TinaX.VFSKit var final_conf = VFSConfHelper.GetPerfectConfig(TinaX.Config.GetTinaXConfig(TinaX.Conf.ConfigPath.vfs));","link":"/2019/10/06/tinax-framework-e8-87-aa-e5-8a-a8-e5-8c-96-e6-9e-84-e5-bb-ba-e5-ae-9e-e8-b7-b5/"},{"title":"Unity3d内建Shader使用概述","text":"Shader是用来控制可编程图形渲染管线的程序。 Unity3d提供了超过80个内建shader着色器。 ![J0BP8$KL31%PGP~WI}%BS4 本文将对各个着色器的用途和特性作简单概述。 Standard -Unity5.x中新加入的基于物理的“标准着色器” Standard（Specular setup） 标准着色器的高光版 FX GUI Mobile Unity针对移动端进行优化的Shader Bumped Diffuse 法线贴图漫反射着色器 Bumped Specular 法线贴图高光着色器 Bumped Specular(1 Directional Light) Diffuse 漫反射着色器 Particles Skybox Unlit(Supports Lightmap) 仅使用纹理颜色，不受光照影响（支持光照贴图） VertexLit 顶点光照着色器 VertexLit(Only Directional Lights) Nature Particles Skybox Sprites UI Unlit 仅使用纹理颜色，不受光照影响 Legacy Shaders 老版本Shader，Unity已不推荐使用","link":"/2018/03/17/unityshader1/"},{"title":"Visual Studio 2019候选发布版体验","text":"虽说VS2019 RC发布好些天了，但也就今天周末来有时间下载下来玩玩，看看VS2019有哪些新的东西。顺便看看Visual Studio的旗舰版有啥有趣的地方。 vs2017是免费的贫下中农版，vs2019预览版是旗舰版 欢迎页 启动VS之后，首先感觉，欢迎页的变化很大。 VS2017的欢迎页是一个子页签，而VS2019的欢迎页则是一个独立的窗口，（感觉很像Unity Hub)。内容上，也把一些可能从来没几个人看过的“开发人员新闻”和“入门”给弄没了。 新建一个控制台项目试试 从VS2017的菜单新建项目，在.net core分类下找到控制台项目，新建。 而2019则有个巨大的新建项目按钮，不知道是不是为了突出2019一直宣传的云端协同，Git和Azure的选项放在了第一个。 不过，点进去之后的页面就很不讨喜了，各种新建项目选项胡乱堆在一起，虽然有筛选功能，但是吧，总觉得有点乱糟糟的。（而且，从菜单选项打开的新建项目界面也是这玩意。 并且新建项目的时候，没有“顺便给这个项目创建git仓库”的选项了 对比两代编辑器，功能区没有什么大变化，菜单UI显得更紧凑了，原来单独占一行的项目标题跑到了菜单后面。 跑hello world的时候，控制台程序结束之后，输出了如图一堆文字。虽然目前看没什么用处，但是相比之前控制塔窗口一闪而过，倒是不至于让刚入门的学生一脸懵逼了。 相较于社区版，旗舰版VS一直就有一些非常方便的小东西，比如引用的标记，Git版本的变化标记之类的","link":"/2019/03/03/visual-studio-2019-e5-80-99-e9-80-89-e5-8f-91-e5-b8-83-e7-89-88-e4-bd-93-e9-aa-8c/"},{"title":"Windows 10 大陆地区生存手册-（1）入门篇","text":"这是一个面向“对计算机/Windows 10完全不懂的群体”的科普文 今天又被人问“我电脑为什么xxx”，讲真，说不嫌烦那是假的，尽管对方会觉得很无辜，但是隔三岔五就得解释一遍这种问题，确实有点不舒服。得，统一整理整理，写点东西吧。 首先，什么是系统，什么是Windows事实上，很多普通人（指不从事计算机相关行业、切对计算机领域没有特别关注的人）对电脑的概念是很模糊的，甚至很多人是不知道什么是系统的。 我们从头开始说起吧，首先，在本文中，我们把电脑分为两个部分：硬件和软件。细节我们不管，类比到人类来说，“硬件”就是人类的“躯体”，包括身体发肤、骨骼内脏等的，而“软件”就是人的“思想”，有宗教信仰的读者可以理解为人的“灵魂”。而我们的电脑，就是它的“思想”在驱使着它的“身体”来完成任务。 系统，完整的说叫“操作系统”，简称“OS”，就是我们电脑中所有软件的老大，它掌管着所有软件的生命和行为。有宗教信仰的读者可以理解为“系统是众多软件子民中唯一的神”。 通常，人会分南方人北方人、亚洲人欧洲人，不同的群体会有不同的生活习惯、不同的语言，一个欧洲人说的话写的字给一个亚洲人大概率就看不懂。而电脑也是一样，电脑里的系统是有区别的，有好多种群的。这些系统中，最常见的有三类：Windows、OS X、GNU Linux. 好的，文章中开始出现英文字母了，有的读者就懵了。但是请冷静，这几个单词就是单纯的起个名字而已，没有任何意思，你要是愿意，也可以把它们叫做“小张”、“老李”、“老赵”，意思是一样的。我们接下来，就从头开始认识一下这些小张、老王们。 WindowsWindows就是本文的主角了，它是一个商品，由美国微软（Microsoft）公司研发和发行。目前在售的版本叫“Windows 10”，可以被安装在电脑、手机、冰箱等各种地方。 通常，如果我们什么都不知道，去超市商场随便买一台常见品牌电脑的话，比如什么戴尔、联想、惠普、小米、苏菲等等，那它大概率安装的就是Windows。 通常，目前本文写出来的这个时间点（2019年），新买的电脑默认安装的是Windows 10 的“家庭版”版本，部分高端机型默认安装的是Windows 10的“专业版本（Pro版本）”。至于它们有什么区别，先不管，就当它是一样的就好了。 OS X刚刚我们说，如果我们去超市商场随便买一台电脑的话，它大概率会安装Windows。但是也有一个特别的牌子，苹果（Apple）。 OS X也是一个商品，由美国苹果（Apple Inc)公司研发。OS X并不像Windows那样直接出售，而只会安装在自己家的电脑产品中，跟随电脑一起发行。 就像我们刚刚说的，欧洲人写的字亚洲人大概率是看不懂的，在系统之间也是一样，Windows上的软件，通常在OS X上是安装不了的，反之亦然。所以不要再问什么“为什么我的电脑下载不了英雄联盟”了，因为那些是Windwos平台独占的。 GNU LinuxGNU Linux准确的说，它不是一个具体的系统，而是一堆系统的统称。GUN Linux起源于上个世纪一个芬兰的大学生，他因为觉得买个系统太贵了，于是一拍脑门：“来，我们自己做一个系统吧” 然后很多人就响应了它的号召，全世界无数软硬件工程师一起参与建设了这么一个企划。（具体故事很复杂，我们不需要懂，粗略的理解就是全世界人一起用爱发电肝了个系统出来） GNU Linux的绝大多数发行版不是商品，属于自由软件。可以免费安装使用。通常，我们买的电脑很少会看到预装Linux系统的，不过也是有的，比如部分神舟机型，比如一些国企的采购任务等等。 开始使用Windows大概介绍了什么是操作系统之后，我们就来好好聊聊本文的主角了，Windows。 注意，本文以普通Windows消费者用户角度来介绍它的最佳使用实践，政企用户的部分内容请以各部分的要求为准。 Microsoft 账户就和很多手机一样，当我们刚把一台电脑买回来，首次开机时，系统会让我们登录或者注册一个账号（如果你电脑买回来首次开机没有要求登录或者注册账号的话，请退货，重新购买并确认包装是否完整未拆封） 我们登录的这个账号就是微软账号，电脑会认为这个账号的主人是这台电脑的主人。和手机一样，只要有了这个账号，你就可以在摸不到电脑的情况下，远程定位、锁定、管理这台电脑，包括修改密码和锁死用户数据。 所以请务必保管好这个账号，也不要随便在自己的电脑上登录别人的账号。 了解Windows的常见界面（传统电脑）当我们解决完账号，首次打开一台新电脑时，我们会看到这样一个界面。 这就是Windows的桌面。 注意，如果你的设备是平板电脑，并且系统在平板电脑模式下，默认是看不到这个样子的桌面的。具体请看后面的单独介绍 整个桌面分为这么几个部分： 一、 托盘 托盘就是底部的深色长条，这里可以显示一些快捷图标，小工具，和系统的一些状态。（有OSX使用经验的读者可以理解为Docker栏+状态栏） 二、开始菜单/开始屏幕点击界面左下角的这个图标，它叫“开始按钮” 我们就能看到我们的开始菜单了。 整个菜单可以分为两个部分：菜单列表和磁贴区域。 其中，当我们新安装了一个软件时，这个软件就会出现在菜单的“菜单列表”中，以名字的首字母顺序排序。如果我们点击下图这样的首字母分类标签 就会看到这样一个界面， 通过点击相应的字母，我们可以迅速定位、找到我们要打开的软件。 而在磁贴区域中，则放置着一些App的“磁贴”，我们可以单击这些“磁贴”来打开相应的应用。我们也可以自己把一些常见的软件放置在磁贴区域，操作方法很简单，对任意软件右键，选择“固定到“开始”屏幕”即可。 开始屏幕上的“磁贴”，和手机上、开始菜单列表、桌面上的软件图标相比，有个明显的不同之处就是，磁贴可以在不打开应用的情况下，显示部分信息。 图为新闻App、天气App 通过对磁贴右键，我们还可以调整它的大小，不过要注意的是，当磁贴为最小的时候，是不会显示这种动态信息的。 通常，我们可以把一些常用的软件给固定到开始屏幕，并对磁贴进行简单的排序： 这样一来，我们工作的时候，只需要按一下键盘上的“Win”键打开开始菜单，就可以很方便的打开一个软件。而如果你把图标都放在桌面上的话，你就不得不先把打开的窗口移开，露出桌面上的图标，然后再双击打开软件。 三、操作中心操作中心，通常是用来显示软件通知、并提供一些快捷操作的地方。类似于手机中的下拉菜单。点击屏幕最右下角的按钮即可打开操作中心面板。 界面呈一个列表状，点击相应的内容，即可打开对应的应用功能，这点与手机上基本一致。鼠标安装列表内容，滑动可以删除项目 而界面下方区域，则提供了一些快捷操作按钮， 了解Windows的常见界面（移动设备）上面介绍了我们常见的传统电脑（台式机、笔记本）中的Windows界面，但是对于有的用户来说，看到的Windows可能就不少这样的了，比如Windows平板或手机用户。 接下来，我们就对比着传统电脑，来讲讲 移动设备中的Windows. 锁屏界面Windows在各个平台上的锁屏界面是一致的，按电源键亮屏之后如图。 Windows 手机 与电脑的“按任意键进入主屏幕”不一样的是，移动设备这玩意大多是没有键可以按的，如果你的设备支持Windows Hello的话，默认情况下是可以自动识别到指纹、面部之后进行解锁的。除此之外，你也可以通过向上滑动来进入和传统电脑一致的密码/PIN密码登录界面 开始屏幕值得注意的是，在移动设备中，解锁之后是直接进入开始屏幕的，移动设备是没有传统的Windows桌面的。 Windows 平板 开始屏幕 Windows 手机 开始屏幕 在平板电脑的开始屏幕界面，我们通过左上方按钮，即可进入开始菜单列表 而在手机的开始屏幕界面，我们通过向左滑动来进入开始菜单列表。 操作中心在平板电脑模式中，我们依然可以点击右下角的图标来调出操作中心面板，不过在很多情况下，托盘是被默认隐藏的，这时候我们可以通过更简单的滑动方式来呼出操作中心面板。 而手机端的操作，与其他手机一致。 切换应用、关闭应用等操作我们发现，在移动设备中，应用都是全屏的，和隔壁iPad一样。如果是习惯了传统电脑的用户就不熟悉了，我要怎么关掉一个应用，或者切换后台呢，如图： 从屏幕顶部向下滑动，可以关闭一个应用，从屏幕左边向右滑动，可以打开Windows时间轴。 如果要使用分屏显示功能的话，则从顶部下滑拖拽窗口之后，向需要贴靠的方向移动。 平板模式切换到桌面模式如果说，我想在平板电脑上也像传统电脑一样使用桌面模式操作，那也是可以的。在操作中心中，我们可以看到切换平板模式的小开关，点一下即可。 另外，对于大部分平板电脑设备，你当你给它插上键盘的时候，它也会自动进入桌面模式。 此外，还有一个我买了平板很久之后才发现的事：微软的Surface系列平板电脑，当键盘叠在背面的时候，不需要拆下键盘，也会进入平板模式。 嘛，以上就是Windows一些基础操作的介绍，如果不鸽的话，下一篇我们来介绍一下，如何在Windows中安全、科学、高效的下载安装和使用软件。","link":"/2019/08/15/windows-10-e5-a4-a7-e9-99-86-e5-9c-b0-e5-8c-ba-e7-94-9f-e5-ad-98-e6-89-8b-e5-86-8c-ef-bc-881-ef-bc-89-e5-85-a5-e9-97-a8-e7-af-87/"},{"title":"Unity Engine的ScriptableSingleton","text":"ScriptableSingleton 是我最近不小心发现的一个类，它位于UnityEditor namespace，但是并没有出现在官方的文档上。 于是，好奇心来了。经过一系列的琢磨和查阅资料，发现它可能是用于编辑器内部记录数据的一个功能（能不能保存数据还不知道） 比方说，我们有两个编辑器窗口，同时需要一个数据，那我们可以把它直接记录在一个变量或者property上。 namespace Nekonya.Example { public static class Demo { public static bool User_Is_A_Cat { get; set; } } } 然后你可以在需要它的地方这么调用它：var b_cat = Demo.User_Is_A_Cat; 但是这时候就有个问题：这些数据很容易丢失。 比如说你改了同项目中的某个其他的代码，触发了Unity的代码重编译，然后你存放在这里的数据就没了。 那这种时候，就可以用ScriptableSingleton 这个小功能来记录数据了。我们写一个这样的类： namespace Nekonya.Example { public class UserInfo : UnityEditor.ScriptableSingleton&lt;UserInfo&gt; { public bool User_Is_A_Cat { get; set; } } } 然后，如果我们要使用它的值的话，就直接访问ScriptableSingleton里面的instance就可以了。 namespace Nekonya.Example { public class TryGetData { void Meow() { var b_cat = ScriptableSingleton&lt;UserInfo&gt;.instance.User_Is_A_Cat; } } } 这样一来，编辑器下的数据就不会丢失了。","link":"/2020/02/28/unity-engine-scriptablesingleton/"},{"title":"【云计算】整理：Ubuntu16.04 安装Docker -CE (社区版)","text":"参考：官网文档https://docs.docker.com/install/linux/docker-ce/ubuntu/#prerequisites 系统要求： Artful 17.10 (Docker CE 17.11 Edge and higher only) Xenial 16.04 (LTS) Trusty 14.04 (LTS) 新的Docker分为社区版（CE）和企业版(EE)，它们对应的软件包名不同。在安装新版本之前，确认卸载旧版本。 $ sudo apt remove docker docker-engine docker.io 然后确保apt可以使用Https sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 添加Docker 官方GPG Key: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - X86_64/AMD64 sudo add-apt-repository \\ “deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable” ARMHF sudo add-apt-repository \\ “deb [arch=armhf] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable” 安装Docker CE apt update apt install docker-ce install success","link":"/2018/02/12/ubuntu-16-04-docker/"}],"tags":[{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"Unity3D","slug":"Unity3D","link":"/tags/Unity3D/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"热更新","slug":"热更新","link":"/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"},{"name":"ScriptableSingleton","slug":"ScriptableSingleton","link":"/tags/ScriptableSingleton/"}],"categories":[{"name":"文字","slug":"文字","link":"/categories/%E6%96%87%E5%AD%97/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"瞎折腾","slug":"文字/瞎折腾","link":"/categories/%E6%96%87%E5%AD%97/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"Unreal","slug":"Unity/Unreal","link":"/categories/Unity/Unreal/"},{"name":"文字","slug":"Unity/文字","link":"/categories/Unity/%E6%96%87%E5%AD%97/"},{"name":"文字","slug":"Unity/Unreal/文字","link":"/categories/Unity/Unreal/%E6%96%87%E5%AD%97/"},{"name":"瞎折腾","slug":"Unity/Unreal/文字/瞎折腾","link":"/categories/Unity/Unreal/%E6%96%87%E5%AD%97/%E7%9E%8E%E6%8A%98%E8%85%BE/"}]}